Build Instructions For OSX

1.  Install Python as a Framework
  - unpack python
  - ./configure --enable-framework
  - make
  - make frameworkinstall

2.  Build BitTorrent
  - python setup.py build

3.  Build BT OSX
  - open project file and click hammer icon
  - note, you may have to point PB to the location of Resources like
the BitTorrent directory and _StreamEncrypter.so if the top-level
build directory created by BT's setup.py script differs in name from
mine.



----------------
HACKING GUIDE

the thing that makes BT-OSX no so straightforward is on the Mac
you don't create a whole new instance of the app for each download.
That means each download runs in it's own thread.  BT uses callbacks
for display updating, which is all well and good, but you con't
reliably draw from any thread but the main thread in Cocoa or your
app will crash.  So what we do is use NSConnection so messages sent
from a Python thread to it's DL window are posted on the main thread
on the next turn of the main event loop.  This complicates setting up
the DL but once things are setup communication between the python
threads and the DL window controller is a simple ObjC message send
(transparently packed up, sent over a Mach port, unpacked, dispatched
on the main event loop, and value returned in the originating thread
if necesary.)

components:

 BTAppController.m - App delegate, loads the DLWindow nibs and starts DLs

 DLWindowController.m - each DL window has one of these as it's delegate, 
it is messaged by the python callbacks to update the DL window

 BTCallbacks.h - ObjC protocol for messages the DLWindowController
responds to; chooseFile, display, and finished callbacks..

 callbacks.m - Python code written in C, our python<->objc bridge
 
 
 here's how it goes:
 
   main.m initializes the Python interpreter and loads our C module
before starting the regular Appkit stuff
   
   when BTAppController starts a new DL, it loads the DLWindow nib and
instantiates a DLWindowController.
   
   BTAppController then makes a pair of NSPorts and an NSConnection
and registers the DLWindowController instance as the root object.
   
   BTAppController makes Python Event object for cancelling the
download, then starts a new thread passing the ports and event flag

   The new thread uses the ports to create an NSConnection to the
DLWindowController, creates a Python proxy object (defined in
callbacks.m,) that encapsulates the DLWindowController NSProxy then
sets up the arguments for the BT download.

  Now when BT calls back, the python callback functions message the
DLWindowController via the NSConnection, with the messages being
dispatched on the main event loop...


   